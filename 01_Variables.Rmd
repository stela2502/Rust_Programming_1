# Variables

Rust uses strong typed variables. This does mean that you need to define your variables as a specific type.
As an example you can store integer values as u8, u16, u32, u64, u128, i8, i16, i32, i64, i128, usize or integer.
All of these types can not be compared against each other. So if you want to create some data structures it does help to choose the same type for all data (eg. integers). 
The difference between the integer types are the range of values they can contain: u8 and i8 are 8 bit long whereas u128 and i128 are 128 bit long; the u types are unsigned and can not contain negative values. 
Usize is the default integer type and is dependent on your computer type. On 64 bit computers it is the same as a u64 - but you still can not compare it directly to u64.

# Examples

For now we will use the extendr package to make this run in Rmd:

```{r, eval=FALSE}
remotes::install_github("extendr/rextendr")
```

And now we can actually look into what the variables contain:

```{extendr}
let x = 5;
let y = 7;
let z = x*y;

rprintln!("{x} * {y} = {z}");
```

So what about strings?

```{extendr}
let seq = "AGCT";
let bseq = b"AGCT";

rprintln!("{seq}");
rprintln!("{bseq:?}");
```


# Create a new Rust program 

I do not use Rust from within R, hence I can not teach that.
It also makes more sense to me to compile Rust programs and use them on the command line.


As an example of why I deliberately broke the integer example:

```
let x:u8 = 5;
let y:u16 = 7;
let z = x*y;

println!("{x} * {y} = {z}");
```

I can not generate this html file here using this code, but if I create a stand alone 'program' of it it works:


```{r , include = FALSE, eval=FALSE}
unlink( 'workshop', recursive=TRUE )
```

```{bash, eval=FALSE}
cargo new workshop --bin
```

Open the created file "workshop/srv/main.rs" and replace the "println!("Hello, world!");" with the wrong code we had before.

```{bash,  error=TRUE}
cd workshop
cargo build -r
```

That was fun. 

# A small Rust program with a function

Now we need to dig deeper and I recommend you to use your programming IDE of choice to look into a different broken program. Rstudio would also do.

Lets look in the simple_problem folder in [this github repo](https://github.com/stela2502/Rust_Programming_1).

Download (clone) the repo using git ``git clone https://github.com/stela2502/Rust_Programming_1``. Open the folder 'simple_problem' in your IDE and open a terminal and cd into this folder.

There you run:
```{bash, eval=F}
cargo build -r
```

It is almost no fun hiding programming erros as the compiler will already tell you what to do - right?
I think this nevertheless will be fun...

## Problem 1

Each line needs to end with a ';'. All but the last line in a function if you want to return a value.

## Promblem 2

We do not have a 'data' variable in the sum function. Here the data is called 'v' - fix that.

Now the code compiles:
```{bash, eval=F}
cargo build -r
target/release/simple_problem
```

Does the output make sense?

## Problem 3

No it is wrong: We need to switch the variables in the println! function.

## Problem 4

Wait - we tried to sum up the values 6, 7, 8 and 9 - that is not 10?!
How do you fix that?

This one is rather complicated, but I am sure you will be able to find out - right?


# Tests in Rust

Rust has a nice way to test scripts and libraryies:
Add this to the script

```
#[cfg(test)]
mod tests {
    use crate::sum;
    #[test]
    fn check_sum() {
      
      let data:Vec<usize> = vec![1,2,3,4,5,6,7,8,9];
      let ids:Vec<usize> = vec![5,6,7,8];
      
    	assert_eq!( sum( &data, &ids ), 30 );
    }
}
```

And now you can test your script by 

```
cargo test -r
```


# A short break


