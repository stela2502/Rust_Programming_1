# How do you get data into Rust?

Getting data into a compiled langue has always been a problem for me.
Hence I'll tell you how I finally managed to get data into Rust - just copy paste the solution - I do the same.

The git repo contains a folder 'read_data' that is a simple Rust package.
Looking into it you see a Cargo.toml. This file describes your package and is comparable to the R DESCRIPTION file.
Here you define the package and the dependancies. Just look into the example. It should be self explanatory.

The src folder contains the code files with main.rs defining the executable, and the lib.rs defining the library part of the package.
The additional data.rs file contains the code for the library in this package and needs to be mentioned in the lib.rs file to be compiled.


Let's dig through the library.


### Start with the main.rs file. 

This file will be compiled to be the executable. The program starts with the main function.

- lines 0..7   import the used classes
- lines 13..22 define the command line options
- lines 24..55 define the main function

In the code most of this is a timer functionality that I do think is extremely useful.

```
let now = SystemTime::now();

...

match now.elapsed() {
    Ok(elapsed) => {
        let mut milli = elapsed.as_millis();
        
        let mil = milli % 1000;
        milli= (milli - mil) /1000;

        let sec = milli % 60;
        milli= (milli -sec) /60;

        let min = milli % 60;
        milli= (milli -min) /60;

        println!("finished in {milli} h {min} min {sec} sec {mil} milli sec");
    },
    Err(e) => {println!("Error: {e:?}");}
}
```

Using 'let <var_name>: <type> = <value>' defines variables in Rust.
The type does not need to be included in the definition if the compiler can identify the type itself.


The 'match' part is the main Rust error handling functionality. 

The next bigger part is the reading of the command line options: 'now.elapsed()' is a function that can fail and therefore returns a "Result<Duration, SystemTimeError>" instead of only a Duration.
This allows for the match to check if an error has occured:

```
match <statement> {
    Ok(<varname>) => { <do something with the variable> },
    Err(e) => { <do something with the error> }#
};
```

I am sure you will like this ;-)



```
let opts: Opts = Opts::parse();
let mut sep = '\t';
if &opts.sep != "\\t"{
    println!("I set sep to {}", opts.sep );
    sep = opts.sep.chars().next().unwrap(); 
}
```

This first parses the command line. The rest is my way to handle the problem that you can not give Rust a '\t' as char as that can only contain one literal.
So I have used the tab as default instead of dealing weith this problem in an other way.

So the final 'work' the tool does is in the left over one lines:

```
let data = Data::read_file( &opts.data , sep );
data.print();
```

This first defines a data variable using the Data::read_file function and then uses the Data::print function to print the contens of the data object.

### And the libraray data.rs

This file defines the Data class.

- lines 0..9 define the dependancies
- lines 11..19 define the data part of the class
- lines 22..196 code the functions
- lines 198..217 implement the tests for this class


### The lib.rs file

```
pub mod data;
```

Oh that is boring. It only imports the thingsfrom data.rs...

# The data.rs file

This file now defines the Data class.

A class in Rust is defined by creating the data structure for the class (struct Data {}) and then implementing functions for the class (impl Data {}).
Functions can be defined with 

```
fn <function name> (<variables>) -> <return value> { 
	<code> 
} 
```

Lets look into the new function:

```
pub fn new( rows:usize, cols:usize, data: Vec::<f64>, rownames: Vec::<String> ) -> Self {

	let ret = Array::from_iter(&mut data.iter().cloned());
	let data = ret.into_shape([rows, cols]).unwrap();
	let store = Array::default((rows, rows));
	let total_energy =  vec![0.0; rows];

	Self {
		rows, 
		cols,
		rownames,
		data,
		total_energy,
		store,
	}
}
```

Here we define the class contents and return a Self object.


### The read_file function

The read_file function shows a general problem of compiled languages.
Normally you should know how much data you want to store in the objects as the memory needs to be requested per variable.
Adding more 'space' to a variable is quite costy. Hence here we iterate over the data twice. Lines 47..62 read the data and 'only' collect the column and row counts.


The 'line' object contains one line of the data file and the reader.lines() function returns a 'Result' - meaning it is normal that this function might not work.
And - again - this is the common way to treat a Result:

```
header =true;
for mut val in line.split( sep ).collect::<Vec<&str>>(){
    if header{
        names.push( val.to_string() );
        header = false;
    }else {
    	val = val.trim();
        let v = match val.parse::<f64>() {
            Ok( v ) => v,
            Err(_err) => {
                match val.parse::<usize>(){
                    Ok(v) =>  { 
                        v as f64
                    },
                    Err(err) => {
                        eprintln!("I could not parse '{val}' to usize or f64 {err:?}");
                        0.0
                    },
                }
            },
        };
        arr.push( v );
    }
}
```

What does this 'mut' mean? Rust differentiates between variables you only store a value in once and variables that you can modify.
So whenever you want to asigne a value to a variable more than once you need to declare the variable as mut.
It also does not allow access to a variable in more than one function.

```
for mut val in line.split( sep ).collect::<Vec<&str>>()
```

Translates to: split the line by 'sep' and give me ownership of the variables you create as Vec<&str> and iterate over the variables in the vector that I want to be able to modify.

Where do we modify the value? ``val = val.trim();`` does remove whitespace from the strings. This is necessary as " 2" can not be parsed as 2:<usize>. Tried that and it broke ;-)
Rust also does not want to parse an int as float and vice versa. So therfore I need to differentiate between the two options here, too. 


I assume you can see what is going on here? What does this function do?


