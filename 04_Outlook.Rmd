# How would we now implements a DNA mapper like STAR?

Fist we would need to see how nucleotide sequences can be handled in Rust.
For this we define that one single DNA nucleotide can either be 'A', 'C', 'G' or 'T' - in other words 4 different options.
So - we could also code for them using 2 bits 'A' = 00, 'C' = 01, 'G' = 10, 'T' = 11.

Each char tahes a u8 to store it internally. That is 8 bits wide and as our very limited DNA code can be coded in only 2 bits this should be 4x as efficient - a single u8 can contain the same info as a 4bp DNA code.

With being an integer this representation of a DNA sequence opens up possibilities that you do simply not have in R.

```{extendr, eval=eval_rextender}
pub type Base = u8;
pub const A: Base = 0;
pub const C: Base = 1;
pub const G: Base = 2;
pub const T: Base = 3;
pub fn encode_binary(c: char) -> Base {
    match c {
        'A' | 'a' => A,
        'C' | 'c' => C,
        'G' | 'g' => G,
        'T' | 't' => T,
        _ => panic!("cannot decode {c} into 2 bit encoding"),
    }
}

let s = String::from("AGCTACGT");
println!("How Rust can look at the sequence {s}");
let t = s.as_bytes();
println!("as_bytes {t:?}");
let st = std::str::from_utf8(t).unwrap();
println!("as str {st:?}");

let mut w = 0_u8;
for c in st.chars().rev() {
  w <<= 2;
  w |= encode_binary(c);
}
println!("and as single u8 integer {w}");
println!("which looks like this in binary form: {w:b}");

let faster =std::str::from_utf8( b"AGCTAGCT").unwrap();

for c in faster.chars().rev() {
  w <<= 2;
  w |= encode_binary(c);
}
println!("and now in one line from string to binary: {w:b}");
```


What does this do? 
In the beginning it defined a Base variable of class type. This variable is later used to define which kind of data you can process using this logic (e.g. 8, 16, 32 or even 64 bp of sequence info). The next four lines define which sequences should be converted into which 'number'.
It helps tremendously if you try to think of 0-3 as binary numbers: #00, #01, #10 and #11.

"Defining something using const instead of let can help make the code more reliable, efficient, and maintainable by enforcing immutability and compile-time evaluation, and by providing global scope and better type checking." For me this translates to - just do it this way - it does certainly not hurt.

The 'let part' of the script defines the string we want to convert, converts the string to a bytes vector ([u8]). The for loop finally converts the str into a Base integer. Can you see what it does - does the initial string really get represented in the u8? Do 8 bp really fit into this u8? And should that not throw an error?

```{bash,  error=TRUE}
cd sequences
cargo build -r 2>&1 | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
target/release/sequences
```


As said - this is not scope of this course, but I assume it will become interesting for you later on.

So what about we try to implement a mapper using this knowledge? This will likely be a horrible experience for you :-D 
